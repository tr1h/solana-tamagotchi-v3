// ============================================
// üí∞ TAMA DOUBLE-ENTRY ACCOUNTING SYSTEM
// ============================================

const TAMAAccounting = {
    
    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
    CONFIG: {
        USE_DATABASE: true,
        DEBIT: 'DEBIT',      // –ü—Ä–∏—Ö–æ–¥ (—É–≤–µ–ª–∏—á–µ–Ω–∏–µ TAMA)
        CREDIT: 'CREDIT'     // –†–∞—Å—Ö–æ–¥ (—É–º–µ–Ω—å—à–µ–Ω–∏–µ TAMA)
    },
    
    // –¢–∏–ø—ã –æ–ø–µ—Ä–∞—Ü–∏–π
    OPERATION_TYPES: {
        // –ü—Ä–∏—Ö–æ–¥—ã (DEBIT)
        MINT_REWARD: 'MINT_REWARD',           // –ù–∞–≥—Ä–∞–¥–∞ –∑–∞ –º–∏–Ω—Ç NFT
        DAILY_LOGIN: 'DAILY_LOGIN',           // –ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è –Ω–∞–≥—Ä–∞–¥–∞
        PET_CLICK: 'PET_CLICK',               // –ö–ª–∏–∫ –ø–æ –ø–∏—Ç–æ–º—Ü—É
        MINIGAME_WIN: 'MINIGAME_WIN',         // –ü–æ–±–µ–¥–∞ –≤ –º–∏–Ω–∏-–∏–≥—Ä–µ
        REFERRAL_REWARD: 'REFERRAL_REWARD',   // –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è –Ω–∞–≥—Ä–∞–¥–∞
        ACHIEVEMENT_REWARD: 'ACHIEVEMENT_REWARD', // –ù–∞–≥—Ä–∞–¥–∞ –∑–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ
        ADMIN_BONUS: 'ADMIN_BONUS',           // –ë–æ–Ω—É—Å –æ—Ç –∞–¥–º–∏–Ω–∞
        
        // –†–∞—Å—Ö–æ–¥—ã (CREDIT)
        SHOP_PURCHASE: 'SHOP_PURCHASE',       // –ü–æ–∫—É–ø–∫–∞ –≤ –º–∞–≥–∞–∑–∏–Ω–µ
        FEEDING_COST: 'FEEDING_COST',         // –°—Ç–æ–∏–º–æ—Å—Ç—å –∫–æ—Ä–º–ª–µ–Ω–∏—è
        HEALING_COST: 'HEALING_COST',         // –°—Ç–æ–∏–º–æ—Å—Ç—å –ª–µ—á–µ–Ω–∏—è
        EVOLUTION_COST: 'EVOLUTION_COST',     // –°—Ç–æ–∏–º–æ—Å—Ç—å —ç–≤–æ–ª—é—Ü–∏–∏
        ADMIN_PENALTY: 'ADMIN_PENALTY'        // –®—Ç—Ä–∞—Ñ –æ—Ç –∞–¥–º–∏–Ω–∞
    },
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    init() {
        console.log('üí∞ TAMA Double-Entry Accounting System initialized');
    },
    
    // –°–æ–∑–¥–∞—Ç—å –∑–∞–ø–∏—Å—å –≤ –∂—É—Ä–Ω–∞–ª–µ –æ–ø–µ—Ä–∞—Ü–∏–π
    async createTransaction(walletAddress, operationType, amount, description, metadata = {}) {
        if (!walletAddress || !operationType || !amount || !description) {
            throw new Error('Missing required parameters for TAMA transaction');
        }
        
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –æ–ø–µ—Ä–∞—Ü–∏–∏ (DEBIT –∏–ª–∏ CREDIT)
        const isDebit = this.isDebitOperation(operationType);
        const actualAmount = isDebit ? Math.abs(amount) : -Math.abs(amount);
        
        const transaction = {
            id: this.generateTransactionId(),
            wallet_address: walletAddress,
            operation_type: operationType,
            amount: actualAmount,
            balance_before: await this.getCurrentBalance(walletAddress),
            balance_after: 0, // –ë—É–¥–µ—Ç —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–æ –ø–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            description: description,
            metadata: metadata,
            created_at: new Date().toISOString(),
            entry_type: isDebit ? this.CONFIG.DEBIT : this.CONFIG.CREDIT
        };
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –±–∞–ª–∞–Ω—Å
        const newBalance = await this.updateBalance(walletAddress, actualAmount);
        transaction.balance_after = newBalance;
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
        if (this.CONFIG.USE_DATABASE && window.Database) {
            await this.saveTransactionToDatabase(transaction);
        }
        
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ localStorage –¥–ª—è –æ—Ñ–ª–∞–π–Ω —Ä–µ–∂–∏–º–∞
        this.saveTransactionToLocal(transaction);
        
        console.log(`üí∞ TAMA Transaction: ${operationType} ${actualAmount} TAMA (${transaction.entry_type})`);
        console.log(`üí∞ Balance: ${transaction.balance_before} ‚Üí ${transaction.balance_after}`);
        
        return transaction;
    },
    
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ–ø–µ—Ä–∞—Ü–∏—è –ø—Ä–∏—Ö–æ–¥–æ–º (DEBIT)
    isDebitOperation(operationType) {
        const debitOperations = [
            this.OPERATION_TYPES.MINT_REWARD,
            this.OPERATION_TYPES.DAILY_LOGIN,
            this.OPERATION_TYPES.PET_CLICK,
            this.OPERATION_TYPES.MINIGAME_WIN,
            this.OPERATION_TYPES.REFERRAL_REWARD,
            this.OPERATION_TYPES.ACHIEVEMENT_REWARD,
            this.OPERATION_TYPES.ADMIN_BONUS
        ];
        return debitOperations.includes(operationType);
    },
    
    // –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å
    async getCurrentBalance(walletAddress) {
        if (this.CONFIG.USE_DATABASE && window.Database) {
            try {
                const { data } = await window.Database.supabase
                    .from('leaderboard')
                    .select('tama')
                    .eq('wallet_address', walletAddress)
                    .single();
                
                return data?.tama || 0;
            } catch (error) {
                console.error('Error getting balance from database:', error);
                return this.getBalanceFromLocal(walletAddress);
            }
        }
        return this.getBalanceFromLocal(walletAddress);
    },
    
    // –û–±–Ω–æ–≤–∏—Ç—å –±–∞–ª–∞–Ω—Å
    async updateBalance(walletAddress, amount) {
        if (this.CONFIG.USE_DATABASE && window.Database) {
            try {
                // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å
                const currentBalance = await this.getCurrentBalance(walletAddress);
                const newBalance = Math.max(0, currentBalance + amount); // –ù–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
                const { error } = await window.Database.supabase
                    .from('leaderboard')
                    .upsert({
                        wallet_address: walletAddress,
                        tama: newBalance,
                        updated_at: new Date().toISOString()
                    });
                
                if (error) {
                    console.error('Error updating balance in database:', error);
                    throw error;
                }
                
                return newBalance;
            } catch (error) {
                console.error('Error updating balance:', error);
                return this.updateBalanceLocal(walletAddress, amount);
            }
        }
        return this.updateBalanceLocal(walletAddress, amount);
    },
    
    // –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
    async saveTransactionToDatabase(transaction) {
        try {
            const { error } = await window.Database.supabase
                .from('tama_transactions')
                .insert([transaction]);
            
            if (error) {
                console.error('Error saving transaction to database:', error);
                throw error;
            }
        } catch (error) {
            console.error('Failed to save transaction to database:', error);
        }
    },
    
    // –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –ª–æ–∫–∞–ª—å–Ω–æ
    saveTransactionToLocal(transaction) {
        try {
            const key = `tama_transactions_${transaction.wallet_address}`;
            const existing = JSON.parse(localStorage.getItem(key) || '[]');
            existing.push(transaction);
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–æ–∫–∞–ª—å–Ω—ã—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
            if (existing.length > 100) {
                existing.splice(0, existing.length - 100);
            }
            
            localStorage.setItem(key, JSON.stringify(existing));
        } catch (error) {
            console.error('Error saving transaction locally:', error);
        }
    },
    
    // –ü–æ–ª—É—á–∏—Ç—å –±–∞–ª–∞–Ω—Å –∏–∑ localStorage
    getBalanceFromLocal(walletAddress) {
        try {
            const key = `tama_balance_${walletAddress}`;
            return parseFloat(localStorage.getItem(key) || '0');
        } catch (error) {
            console.error('Error getting balance from local storage:', error);
            return 0;
        }
    },
    
    // –û–±–Ω–æ–≤–∏—Ç—å –±–∞–ª–∞–Ω—Å –≤ localStorage
    updateBalanceLocal(walletAddress, amount) {
        try {
            const key = `tama_balance_${walletAddress}`;
            const currentBalance = this.getBalanceFromLocal(walletAddress);
            const newBalance = Math.max(0, currentBalance + amount);
            localStorage.setItem(key, newBalance.toString());
            return newBalance;
        } catch (error) {
            console.error('Error updating balance in local storage:', error);
            return 0;
        }
    },
    
    // –ü–æ–ª—É—á–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
    async getTransactionHistory(walletAddress, limit = 50) {
        if (this.CONFIG.USE_DATABASE && window.Database) {
            try {
                const { data, error } = await window.Database.supabase
                    .from('tama_transactions')
                    .select('*')
                    .eq('wallet_address', walletAddress)
                    .order('created_at', { ascending: false })
                    .limit(limit);
                
                if (error) {
                    console.error('Error getting transaction history from database:', error);
                    return this.getTransactionHistoryLocal(walletAddress, limit);
                }
                
                return data || [];
            } catch (error) {
                console.error('Error getting transaction history:', error);
                return this.getTransactionHistoryLocal(walletAddress, limit);
            }
        }
        return this.getTransactionHistoryLocal(walletAddress, limit);
    },
    
    // –ü–æ–ª—É—á–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –∏–∑ localStorage
    getTransactionHistoryLocal(walletAddress, limit = 50) {
        try {
            const key = `tama_transactions_${walletAddress}`;
            const transactions = JSON.parse(localStorage.getItem(key) || '[]');
            return transactions.slice(-limit).reverse();
        } catch (error) {
            console.error('Error getting transaction history from local storage:', error);
            return [];
        }
    },
    
    // –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å ID —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
    generateTransactionId() {
        return `tama_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    },
    
    // –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –æ–ø–µ—Ä–∞—Ü–∏—è–º
    async getOperationStats(walletAddress, period = 'all') {
        const transactions = await this.getTransactionHistory(walletAddress, 1000);
        
        const stats = {
            total_earned: 0,
            total_spent: 0,
            net_balance: 0,
            operations_count: {
                earned: 0,
                spent: 0
            },
            by_type: {}
        };
        
        transactions.forEach(transaction => {
            const amount = Math.abs(transaction.amount);
            
            if (transaction.entry_type === this.CONFIG.DEBIT) {
                stats.total_earned += amount;
                stats.operations_count.earned++;
            } else {
                stats.total_spent += amount;
                stats.operations_count.spent++;
            }
            
            if (!stats.by_type[transaction.operation_type]) {
                stats.by_type[transaction.operation_type] = {
                    count: 0,
                    total_amount: 0
                };
            }
            
            stats.by_type[transaction.operation_type].count++;
            stats.by_type[transaction.operation_type].total_amount += amount;
        });
        
        stats.net_balance = stats.total_earned - stats.total_spent;
        
        return stats;
    },
    
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ª–∏ TAMA –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–∏
    async canAfford(walletAddress, amount) {
        const balance = await this.getCurrentBalance(walletAddress);
        return balance >= amount;
    },
    
    // –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ —Å–æ–∑–¥–∞–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
    async earnTAMA(walletAddress, amount, reason, metadata = {}) {
        return await this.createTransaction(
            walletAddress,
            this.OPERATION_TYPES.PET_CLICK,
            amount,
            `Earned ${amount} TAMA: ${reason}`,
            metadata
        );
    },
    
    async spendTAMA(walletAddress, amount, reason, operationType, metadata = {}) {
        if (!(await this.canAfford(walletAddress, amount))) {
            throw new Error(`Insufficient TAMA balance. Required: ${amount}, Available: ${await this.getCurrentBalance(walletAddress)}`);
        }
        
        return await this.createTransaction(
            walletAddress,
            operationType,
            amount,
            `Spent ${amount} TAMA: ${reason}`,
            metadata
        );
    }
};

// –≠–∫—Å–ø–æ—Ä—Ç
window.TAMAAccounting = TAMAAccounting;

// –ê–≤—Ç–æ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
document.addEventListener('DOMContentLoaded', () => {
    TAMAAccounting.init();
});

console.log('üí∞ TAMA Double-Entry Accounting System loaded');
